<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis</title>
    <link rel="stylesheet" href="analysis-styles.css?v=3">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="nav-items-container">
            <div class="nav-item" onclick="window.location.href='index.html'">오늘의 학습</div>
            <div class="nav-item" style="color: #32FF8A;">분석리포트</div>
            <div class="nav-item">베스트 리라이팅</div>
            <div class="nav-item" onclick="window.location.href='mypage.html'">마이페이지</div>
        </div>
        <div class="nav-icon">[→</div>
    </nav>

    <!-- Main Content -->
    <main class="main">
        <!-- Title Section -->
        <section class="title-section animate-on-scroll">
            <h1 class="main-title">분석 리포트</h1>
            <div class="title-description">
                <p class="description-text">
                    이 리포트는 당신의 언어 능력을 종합적으로 분석하여 어휘 표현력, 문장 구성, 논리적 전개 등 다양한 측면에서의 성취도를 보여줍니다. 
                    각 영역별 세부 분석을 통해 향후 학습 방향을 제시하고, 개선점을 명확히 파악할 수 있습니다.
                </p>
                <div class="word-count">334/400</div>
            </div>
        </section>

        <!-- Analysis Summary Section -->
        <section class="analysis-dashboard animate-on-scroll">
            <h2 class="section-title">분석 대시보드</h2>
            <div class="dashboard-grid">
                <!-- Top Row -->
                <div class="dashboard-row-top">
                    <!-- Left: Vocabulary Score -->
                    <div class="vocabulary-score">
                    <h3 class="subtitle">어휘표현력 총점</h3>
                    <div class="score-highlight">설득 장인</div>
                    <p class="score-description">문장을 설계하고, 단어를 조율하는 감각이 뛰어납니다!</p>
                    
                    <!-- Circular Gauge Chart -->
                    <div class="gauge-container">
                        <svg class="gauge-chart" viewBox="0 0 200 200">
                            <circle class="gauge-background" cx="100" cy="100" r="80" fill="none" stroke="#2a2a2a" stroke-width="40"/>
                            <circle class="gauge-progress" cx="100" cy="100" r="80" fill="none" stroke="#32FF8A" stroke-width="40" 
                                    stroke-dasharray="0 502.4" stroke-linecap="round" transform="rotate(-90 100 100)"/>
                        </svg>
                        <div class="gauge-text">
                            <span class="gauge-number">0</span>
                            <span class="gauge-max">/100</span>
                        </div>
                    </div>
                </div>

                <!-- Right: Percentile -->
                <div class="percentile">
                    <h3 class="subtitle">성과 백분위</h3>
                    <div class="percentile-details">
                        <div class="percentile-info">
                            <span class="percentile-score">상위 40%</span>
                            <span class="percentile-description">60%의 사용자보다 높은 점수</span>
                        </div>
                        <ul class="percentile-list">
                            <li>대졸 이상, 혹은 독서량이 많은 성인군에서 흔히 볼 수 있는 수준</li>
                            <li>주제에 대한 통찰과 고급 어휘 사용이 돋보임</li>
                        </ul>
                    </div>
                    
                    <!-- Bell Curve Chart -->
                    <div class="bell-curve-container">
                        <canvas id="percentileChart"></canvas>
                        <!-- Animated red dot -->
                        <div class="animated-red-dot" id="animatedRedDot"></div>
                        
                    </div>
                </div>
                </div>

                <!-- Bottom Row -->
                <div class="dashboard-row-bottom">
                    <!-- Bottom Left: Radar Chart -->
                <div class="radar-chart-container">
                    <h3 class="radar-chart-title">분야별 점수</h3>
                    <div class="radar-content">
                        <svg class="radar-chart" viewBox="0 0 400 300">
                            <!-- Grid.svg 이미지를 배경으로 사용 -->
                            <image href="Grid.svg" x="0" y="0" width="400" height="300" preserveAspectRatio="xMidYMid meet"/>
                            
                            <!-- 데이터 막대 (라인) -->
                            <line class="data-bar vocabulary" x1="200" y1="240" x2="200" y2="240"/>
                            <line class="data-bar difficulty" x1="200" y1="240" x2="200" y2="240"/>
                            <line class="data-bar structure"  x1="200" y1="240" x2="200" y2="240"/>
                            <line class="data-bar logic"      x1="200" y1="240" x2="200" y2="240"/>
                        </svg>
                        
                        <!-- Legend -->
                        <div class="radar-legend">
                            <div class="legend-item">
                                <span class="legend-color vocabulary"></span>
                                <div class="legend-content">
                                    <span class="legend-text">어휘 다양성</span>
                                    <span class="legend-score">86<span class="legend-max">/100</span></span>
                                </div>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color difficulty"></span>
                                <div class="legend-content">
                                    <span class="legend-text">어휘 난이도</span>
                                    <span class="legend-score">89<span class="legend-max">/100</span></span>
                                </div>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color structure"></span>
                                <div class="legend-content">
                                    <span class="legend-text">문장 구성</span>
                                    <span class="legend-score">80<span class="legend-max">/100</span></span>
                                </div>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color logic"></span>
                                <div class="legend-content">
                                    <span class="legend-text">논리적 전개</span>
                                    <span class="legend-score">90<span class="legend-max">/100</span></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right: Bar Chart -->
                <div class="bar-chart-container">
                    <h3 class="bar-chart-title">어휘 수준 분석</h3>
                    <div class="bar-chart">
                        <div class="stacked-bar-container">
                            <div class="stacked-bar">
                                <div class="bar-segment grade-a" data-percentage="20"></div>
                                <div class="bar-segment grade-b" data-percentage="45"></div>
                                <div class="bar-segment grade-c" data-percentage="25"></div>
                                <div class="bar-segment foreign" data-percentage="10"></div>
                            </div>
                            <div class="bar-labels">
                                <div class="label-item">
                                    <span class="label-color grade-a"></span>
                                    <span class="label-text">A 등급</span>
                                    <span class="label-percentage">20%</span>
                                </div>
                                <div class="label-item">
                                    <span class="label-color grade-b"></span>
                                    <span class="label-text">B 등급</span>
                                    <span class="label-percentage">45%</span>
                                </div>
                                <div class="label-item">
                                    <span class="label-color grade-c"></span>
                                    <span class="label-text">C 등급</span>
                                    <span class="label-percentage">25%</span>
                                </div>
                                <div class="label-item">
                                    <span class="label-color foreign"></span>
                                    <span class="label-text">외래어</span>
                                    <span class="label-percentage">10%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                </div>
            </div>
        </section>

        <!-- Detailed Analysis Results Section -->
        <section class="detailed-analysis animate-on-scroll">
            <h2 class="section-title">상세 분석 결과</h2>
            <div class="vocabulary-analysis">
                <h3 class="subtitle">어휘 난이도 및 수준 분석</h3>
                <p class="analysis-note">아래 어휘들은 <span class="highlight-percent">상위 15%</span>에서 주로 쓰여요!</p>
                
                <!-- Vocabulary Cards -->
                <div class="vocabulary-cards">
                    <div class="vocab-card card-1">
                        <div class="card-word">진정성</div>
                        <div class="card-pos">명사</div>
                        <div class="card-desc">추상적 개념. 철학적 및 윤리적 담론에서 자주 사용</div>
                    </div>
                    <div class="vocab-card card-2">
                        <div class="card-word">익명성</div>
                        <div class="card-pos">명사</div>
                        <div class="card-desc">사회학적 개념. 정보통신 분야와 연계된 고급어</div>
                    </div>
                    <div class="vocab-card card-3">
                        <div class="card-word">팽배하다</div>
                        <div class="card-pos">동사</div>
                        <div class="card-desc">산문/논설문에서 주로 사용되는 고난도 어휘</div>
                    </div>
                    <div class="vocab-card card-4">
                        <div class="card-word">가짜뉴스/AI 이미지</div>
                        <div class="card-pos">명사</div>
                        <div class="card-desc">현대사회적 맥락 반영. 시사적, 정보미디어적 감수성 포함</div>
                    </div>
                    <div class="vocab-card card-5">
                        <div class="card-word">피상적인 관계</div>
                        <div class="card-pos">명사</div>
                        <div class="card-desc">감정과 관계를 설명하는 고급 심리사회적 어휘</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Sentence Structure Section -->
        <section class="sentence-structure animate-on-scroll">
            <h3 class="subtitle">문장 구조 및 논리성</h3>
            <p class="structure-note">자신의 생각을 우수하게 표현하시네요!</p>
            <div class="structure-content">
                <p class="structure-text">복잡한 주제를 명확하고 논리적으로 전개하는 능력이 뛰어납니다. 고급 어휘를 적절한 맥락에 배치하여 의미를 명확하게 전달합니다. 문장 간의 연결성이 자연스럽게 유지되어 전체적인 흐름이 매끄럽습니다. 추상적 개념을 구체적인 예시와 함께 설명하여 이해도를 높입니다.</p>
            </div>
        </section>

        <!-- Rewriting Suggestion Section -->
        <section class="rewriting-suggestion animate-on-scroll">
            <h3 class="subtitle">리라이팅 제안</h3>
            <p class="suggestion-note">아래는 <span class="highlight-percent">상위 3%</span> 회원님의 글입니다!</p>
            <div class="suggestion-content">
                <p class="suggestion-text">
                    디지털 시대의 익명성은 양면성을 지닌다. 한편으로는 자유로운 의견 표현을 가능하게 하여 민주주의의 발전에 기여하지만, 
                    다른 한편으로는 책임감 없는 발언과 가짜뉴스의 확산을 조장할 수 있다. 이러한 맥락에서 우리는 익명성의 장단점을 
                    균형 있게 바라보고, 건전한 온라인 문화 조성을 위한 노력이 필요하다.
                </p>
            </div>
        </section>

        <!-- Action Buttons -->
        <div class="action-buttons-container animate-on-scroll">
            <button class="print-button" onclick="window.print()">
                <svg class="print-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z"></path>
                </svg>
                인쇄하기
            </button>
            <button class="home-button" onclick="window.location.href='index.html'">홈으로 가기</button>
            <button class="gpt-button" onclick="analyzeWithGPT()" style="background: #10A37F; color: white; border: none; padding: 0.8rem 1.5rem; border-radius: 8px; cursor: pointer; margin-left: 1rem;">🤖 GPT 분석</button>
        </div>
    </main>

    <!-- api-key.js는 로컬에서만 사용, Vercel에서는 환경변수 사용 -->
    <script src="api-config.js?v=3"></script>
    <script src="analysis-script.js?v=3"></script>
    
    <!-- Test script to check if JavaScript is working -->
    <script>
        // analyzeWithGPT 함수는 analysis-script.js에서 정의됨
        console.log('HTML inline script executed!');
        console.log('Current URL:', window.location.href);
        console.log('Search params:', window.location.search);
        
        // GPT 분석 버튼은 onclick으로 처리됨
        
        // Test URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const text = urlParams.get('text');
        const topic = urlParams.get('topic');
        console.log('Text param:', text);
        console.log('Topic param:', topic);
        
        // Test if we can find the title description element
        setTimeout(() => {
            const titleDesc = document.querySelector('.title-description');
            console.log('Title description element found:', titleDesc);
            
            // Try URL parameters first
            if (text && topic && titleDesc) {
                console.log('URL parameters found, updating title description');
                const decodedText = decodeURIComponent(text);
                const decodedTopic = decodeURIComponent(topic);
                
                titleDesc.innerHTML = `
                    <div class="written-topic">
                        ${decodedTopic}
                    </div>
                    <div class="written-text">
                        ${decodedText}
                    </div>
                    <div class="word-count">${decodedText.length}/300</div>
                `;
                console.log('Title description updated successfully from URL parameters');
            } else {
                // Try localStorage as backup
                console.log('URL parameters not found, trying localStorage');
                const storedText = localStorage.getItem('analysis_text');
                const storedTopic = localStorage.getItem('analysis_topic');
                console.log('Stored text:', storedText);
                console.log('Stored topic:', storedTopic);
                
                if (storedText && storedTopic && titleDesc) {
                    console.log('LocalStorage data found, updating title description');
                    titleDesc.innerHTML = `
                        <div class="written-topic">
                            ${storedTopic}
                        </div>
                        <div class="written-text">
                            ${storedText}
                        </div>
                        <div class="word-count">${storedText.length}/300</div>
                    `;
                    console.log('Title description updated successfully from localStorage');
                    
                } else {
                    console.log('No data found in URL parameters or localStorage, using default text');
                    // 기본 텍스트 표시
                    if (titleDesc) {
                        titleDesc.innerHTML = `
                            <div class="written-topic">
                                디지털 시대의 익명성
                            </div>
                            <div class="written-text">
                                디지털 시대의 익명성은 양면성을 지닌다. 한편으로는 자유로운 의견 표현을 가능하게 하여 민주주의의 발전에 기여하지만, 다른 한편으로는 책임감 없는 발언과 가짜뉴스의 확산을 조장할 수 있다. 이러한 맥락에서 우리는 익명성의 장단점을 균형 있게 바라보고, 건전한 온라인 문화 조성을 위한 노력이 필요하다.
                            </div>
                            <div class="word-count">287/300</div>
                        `;
                        console.log('Default text displayed');
                    }
                }
            }
        }, 1000);
        
        // Test function with sample text and complete analysis
        window.testWithSampleText = function() {
            console.log('🧪 테스트 시작 - GPT 토큰 없이 샘플 데이터로 모든 차트 테스트');
            
            // 1. 제목 설명 업데이트
            const titleDesc = document.querySelector('.title-description');
            if (titleDesc) {
                titleDesc.innerHTML = `
                    <div class="written-topic">
                        디지털 시대의 익명성
                    </div>
                    <div class="written-text">
                        디지털 시대의 익명성은 양면성을 지닌다. 한편으로는 자유로운 의견 표현을 가능하게 하여 민주주의의 발전에 기여하지만, 다른 한편으로는 책임감 없는 발언과 가짜뉴스의 확산을 조장할 수 있다. 이러한 맥락에서 우리는 익명성의 장단점을 균형 있게 바라보고, 건전한 온라인 문화 조성을 위한 노력이 필요하다.
                    </div>
                    <div class="word-count">287/300</div>
                `;
                console.log('✅ 제목 설명 업데이트 완료');
            }
            
            
            // 3. 랜덤 샘플 분석 결과 생성 (매번 다른 결과)
            const generateRandomScore = () => Math.floor(Math.random() * 40) + 60; // 60-100점
            const generateRandomPercentile = () => Math.floor(Math.random() * 60) + 20; // 20-80번째 백분위
            
            const vocabulary_score = generateRandomScore();
            const structure_score = generateRandomScore();
            const logic_score = generateRandomScore();
            const creativity_score = generateRandomScore();
            const overall_score = Math.floor((vocabulary_score + structure_score + logic_score + creativity_score) / 4);
            const percentile = generateRandomPercentile();
            
            const sampleResult = {
                vocabulary_score: vocabulary_score,
                structure_score: structure_score,
                logic_score: logic_score,
                creativity_score: creativity_score,
                overall_score: overall_score,
                strengths: ["구체적인 예시 사용", "논리적 전개", "적절한 어휘 선택"],
                improvements: ["문장 연결성 강화", "더 다양한 표현 사용"],
                detailed_analysis: `이 글은 주제에 대한 명확한 이해를 보여주며, 구체적인 예시를 활용하여 주장을 뒷받침하고 있습니다. 어휘력 ${vocabulary_score}점, 구조 ${structure_score}점, 논리 ${logic_score}점, 창의성 ${creativity_score}점으로 종합 ${overall_score}점을 기록했습니다. 특히 양면성을 균형 있게 제시한 점이 인상적입니다.`,
                percentile: percentile,
                rewritten_text: "디지털 시대의 익명성은 복합적인 특성을 지닌다. 긍정적 측면에서는 자유로운 의견 표현을 통해 민주주의 발전에 기여하지만, 부정적 측면에서는 무책임한 발언과 가짜뉴스 확산의 원인이 되기도 한다. 따라서 우리는 익명성의 이중성을 인식하고, 건전한 디지털 문화 조성을 위한 적극적인 노력이 필요하다."
            };
            
            console.log('🎲 랜덤 결과 생성:', {
                vocabulary: vocabulary_score,
                structure: structure_score,
                logic: logic_score,
                creativity: creativity_score,
                overall: overall_score,
                percentile: percentile
            });
            
            // 4. 모든 차트와 텍스트 업데이트
            console.log('🔄 모든 차트 업데이트 시작...');
            
            try {
                // 게이지 차트 업데이트
                if (typeof updateGaugeChart === 'function') {
                    updateGaugeChart(sampleResult.overall_score);
                    console.log('✅ 게이지 차트 업데이트 완료');
                } else {
                    console.log('❌ updateGaugeChart 함수를 찾을 수 없습니다');
                }
                
                // 백분위 차트 업데이트 (정규분포 곡선을 따라)
                if (typeof updatePercentileChart === 'function') {
                    updatePercentileChart(sampleResult.percentile);
                    console.log('✅ 백분위 차트 업데이트 완료');
                } else {
                    console.log('❌ updatePercentileChart 함수를 찾을 수 없습니다');
                }
                
                // 레이더 차트 업데이트
                if (typeof updateRadarChart === 'function') {
                    updateRadarChart([sampleResult.vocabulary_score, sampleResult.structure_score, sampleResult.logic_score, sampleResult.creativity_score]);
                    console.log('✅ 레이더 차트 업데이트 완료');
                } else {
                    console.log('❌ updateRadarChart 함수를 찾을 수 없습니다');
                }
                
                // 막대 차트 업데이트
                if (typeof updateBarChart === 'function') {
                    updateBarChart(sampleResult);
                    console.log('✅ 막대 차트 업데이트 완료');
                } else {
                    console.log('❌ updateBarChart 함수를 찾을 수 없습니다');
                }
                
                // 텍스트 요소 업데이트
                if (typeof updateTextElements === 'function') {
                    updateTextElements(sampleResult);
                    console.log('✅ 텍스트 요소 업데이트 완료');
                } else {
                    console.log('❌ updateTextElements 함수를 찾을 수 없습니다');
                }
                
                // 구조 및 논리성 섹션 업데이트
                if (typeof updateStructureAndLogicSection === 'function') {
                    updateStructureAndLogicSection(sampleResult);
                    console.log('✅ 구조 및 논리성 섹션 업데이트 완료');
                } else {
                    console.log('❌ updateStructureAndLogicSection 함수를 찾을 수 없습니다');
                }
                
                // 리라이팅 제안 업데이트
                if (typeof updateRewritingSuggestion === 'function') {
                    updateRewritingSuggestion(sampleResult);
                    console.log('✅ 리라이팅 제안 업데이트 완료');
                } else {
                    console.log('❌ updateRewritingSuggestion 함수를 찾을 수 없습니다');
                }
                
            } catch (error) {
                console.error('❌ 테스트 중 오류 발생:', error);
            }
            
            console.log('🎉 모든 테스트 완료! GPT 토큰 없이 모든 기능이 정상 작동합니다.');
        };
        
        console.log('Test function available: testWithSampleText()');
        
        // analyzeWithGPT 함수는 이미 위에서 정의됨
                // GPT API 호출
                const result = await analyzeText(text, topic);
                
                if (result.error) {
                    console.error('GPT 분석 오류:', result.error);
                    alert('분석 중 오류가 발생했습니다: ' + result.error);
                    return;
                }
                
                console.log('GPT 분석 결과:', result);
                console.log('전체 응답 키들:', Object.keys(result));
                console.log('advanced_vocabulary 데이터:', result.advanced_vocabulary);
                console.log('advanced_vocabulary 타입:', typeof result.advanced_vocabulary);
                console.log('advanced_vocabulary 배열 여부:', Array.isArray(result.advanced_vocabulary));
                console.log('전체 응답 데이터:', JSON.stringify(result, null, 2));
                
                // 결과를 페이지에 표시
                updateAnalysisWithGPTResult(result);
                
            } catch (error) {
                console.error('GPT 분석 중 오류:', error);
                alert('분석 중 오류가 발생했습니다: ' + error.message);
            } finally {
                // 분석 완료
                console.log('GPT 분석 완료');
            }
        }
        
        // 함수를 여러 방법으로 전역에 할당
        window.analyzeWithGPT = analyzeWithGPT;
        window['analyzeWithGPT'] = analyzeWithGPT;
        
        // 함수 정의 확인
        console.log('analyzeWithGPT 함수 정의 완료:', typeof analyzeWithGPT);
        console.log('window.analyzeWithGPT:', typeof window.analyzeWithGPT);
        console.log('window["analyzeWithGPT"]:', typeof window['analyzeWithGPT']);
        
        // GPT 분석 버튼은 인라인 onclick으로 처리됨
        console.log('GPT 분석 버튼은 인라인 onclick으로 설정됨');
        
        // GPT 분석 결과를 페이지에 업데이트하는 함수
        window.updateAnalysisWithGPTResult = function(result) {
            console.log('Updating charts with GPT result:', result);
            
            // 1. 원형 게이지 차트 업데이트
            updateGaugeChart(result.overall_score || result.vocabulary_score || 0);
            
            // 2. 백분위 차트 업데이트
            updatePercentileChart(result.percentile || 0);
            
            // 3. 레이더 차트 업데이트
            updateRadarChart(result);
            
            // 4. 막대 차트 업데이트
            updateBarChart(result);
            
            // 5. 텍스트 업데이트
            updateTextElements(result);
            
            // 6. 어휘 카드 업데이트
            updateVocabularyCards(result);
            
            // 7. 상세 분석 결과 추가 제거 (title-description에 추가하지 않음)
            
            alert('GPT 분석이 완료되었습니다!');
        }
        
        // 원형 게이지 차트 업데이트
        window.updateGaugeChart = function(score) {
            const gaugeProgress = document.querySelector('.gauge-progress');
            const gaugeNumber = document.querySelector('.gauge-number');
            
            if (gaugeProgress && gaugeNumber) {
                // 점수에 따른 원주 계산 (0-100을 0-502.4로 변환)
                const circumference = 502.4;
                const progress = (score / 100) * circumference;
                
                gaugeProgress.style.strokeDasharray = `${progress} ${circumference}`;
                gaugeNumber.textContent = score;
                
                console.log('Gauge chart updated:', score);
            } else {
                console.error('Gauge chart elements not found:', { gaugeProgress, gaugeNumber });
            }
        }
        
        // 백분위 차트 업데이트
        window.updatePercentileChart = function(percentile) {
            const percentileScore = document.querySelector('.percentile-score');
            const percentileList = document.querySelector('.percentile-list');
            
            console.log('Updating percentile chart:', percentile);
            console.log('Elements found:', { percentileScore, percentileList });
            
            if (percentileScore) {
                percentileScore.textContent = `상위 ${100 - percentile}%`;
            }
            
            // 원래 백분위 차트 로직 사용 (정규분포 곡선을 따라가면서)
            if (window.updateScore && typeof percentile === 'number' && percentile >= 0 && percentile <= 100) {
                // percentile은 상위 몇 %이므로, 0-100 점수로 변환
                // 예: 상위 40% = 60점
                const scorePercent = 100 - percentile;
                window.updateScore(scorePercent);
            } else {
                console.log('updateScore function not available, using fallback');
                // Fallback: 단순 위치 설정
                const animatedRedDot = document.getElementById('animatedRedDot');
                if (animatedRedDot) {
                    animatedRedDot.style.left = `${percentile}%`;
                    animatedRedDot.style.top = '50%';
                    animatedRedDot.style.opacity = '1';
                }
            }
            
            // percentile-list 문장들 업데이트
            if (percentileList) {
                let percentileDescription = '';
                let percentileDetails = '';
                
                if (percentile >= 90) {
                    percentileDescription = '상위 10%';
                    percentileDetails = '전문가 수준의 글쓰기 실력을 보여줍니다. 문학적 표현과 깊이 있는 사고가 돋보입니다.';
                } else if (percentile >= 80) {
                    percentileDescription = '상위 20%';
                    percentileDetails = '대졸 이상, 혹은 독서량이 많은 성인군에서 흔히 볼 수 있는 수준입니다. 주제에 대한 통찰과 고급 어휘 사용이 돋보입니다.';
                } else if (percentile >= 70) {
                    percentileDescription = '상위 30%';
                    percentileDetails = '일반적인 대학생 수준의 글쓰기 실력입니다. 논리적 구성과 적절한 어휘 사용이 잘 드러납니다.';
                } else if (percentile >= 60) {
                    percentileDescription = '상위 40%';
                    percentileDetails = '고등학생 상위권 수준의 글쓰기 실력입니다. 기본적인 문장 구성과 표현력이 양호합니다.';
                } else if (percentile >= 50) {
                    percentileDescription = '상위 50%';
                    percentileDetails = '평균적인 글쓰기 실력입니다. 더 많은 연습과 독서를 통해 실력을 향상시킬 수 있습니다.';
                } else if (percentile >= 40) {
                    percentileDescription = '상위 60%';
                    percentileDetails = '기본적인 글쓰기 능력을 갖추고 있습니다. 문장 구조와 어휘 사용에 더 신경 쓸 필요가 있습니다.';
                } else if (percentile >= 30) {
                    percentileDescription = '상위 70%';
                    percentileDetails = '글쓰기 기초를 다지는 단계입니다. 꾸준한 연습을 통해 실력을 향상시킬 수 있습니다.';
                } else if (percentile >= 20) {
                    percentileDescription = '상위 80%';
                    percentileDetails = '글쓰기 학습이 필요한 단계입니다. 기본 문법과 어휘 학습에 집중하세요.';
                } else {
                    percentileDescription = '상위 90%';
                    percentileDetails = '글쓰기 기초부터 차근차근 학습이 필요한 단계입니다. 기초 문법과 어휘력 향상에 집중하세요.';
                }
                
                percentileList.innerHTML = `
                    <li>${percentileDetails}</li>
                    <li>${percentileDescription} 수준의 글쓰기 실력을 보여줍니다.</li>
                `;
            }
            
            console.log('Percentile chart updated:', percentile);
        }
        
        // 레이더 차트 업데이트
        window.updateRadarChart = function(result) {
            const dataBars = document.querySelectorAll('.data-bar');
            const legendScores = document.querySelectorAll('.legend-score');
            
            const scores = [
                result.vocabulary_score || 0,
                result.structure_score || 0,
                result.logic_score || 0,
                result.creativity_score || 0
            ];
            
            dataBars.forEach((bar, index) => {
                if (scores[index] !== undefined) {
                    // 점수를 높이로 변환 (0-100을 0-60px로 변환)
                    const height = (scores[index] / 100) * 60;
                    bar.style.height = `${height}px`;
                    // 색상은 변경하지 않음 (기존 CSS 색상 유지)
                }
            });
            
            legendScores.forEach((score, index) => {
                if (scores[index] !== undefined) {
                    score.textContent = `${scores[index]}/100`;
                }
            });
            
            console.log('Radar chart updated:', scores);
        }
        
        // 막대 차트 업데이트 (점수에 따른 어휘 수준 분포)
        window.updateBarChart = function(result) {
            const barSegments = document.querySelectorAll('.bar-segment');
            const labelPercentages = document.querySelectorAll('.label-percentage');
            
            console.log('Updating bar chart:', result);
            console.log('Bar elements found:', { barSegments: barSegments.length, labelPercentages: labelPercentages.length });
            
            // 점수에 따른 어휘 수준 분포 계산
            const overallScore = result.overall_score || 0;
            let distribution;
            
            if (overallScore >= 90) {
                distribution = [40, 35, 20, 5]; // A등급, B등급, C등급, 외래어
            } else if (overallScore >= 80) {
                distribution = [30, 40, 25, 5];
            } else if (overallScore >= 70) {
                distribution = [20, 45, 30, 5];
            } else if (overallScore >= 60) {
                distribution = [10, 35, 45, 10];
            } else {
                distribution = [5, 25, 50, 20];
            }
            
            barSegments.forEach((segment, index) => {
                if (distribution[index] !== undefined) {
                    segment.setAttribute('data-percentage', distribution[index]);
                    console.log(`Bar segment ${index} updated to ${distribution[index]}%`);
                }
            });
            
            labelPercentages.forEach((percentage, index) => {
                if (distribution[index] !== undefined) {
                    percentage.textContent = `${distribution[index]}%`;
                }
            });
            
            console.log('Bar chart updated:', distribution);
        }
        
        // 텍스트 요소들 업데이트
        window.updateTextElements = function(result) {
            const scoreHighlight = document.querySelector('.score-highlight');
            const scoreDescription = document.querySelector('.score-description');
            
            if (scoreHighlight) {
                const overallScore = result.overall_score || 0;
                let level = '';
                
                if (overallScore >= 90) level = '글쓰기 마스터';
                else if (overallScore >= 80) level = '설득 장인';
                else if (overallScore >= 70) level = '표현의 달인';
                else if (overallScore >= 60) level = '성장하는 작가';
                else level = '열정적인 초보';
                
                scoreHighlight.textContent = level + '/';
            }
            
            if (scoreDescription) {
                if (result.detailed_analysis) {
                    // 100자 이내에서 문장이 완성되도록 처리
                    let text = result.detailed_analysis;
                    if (text.length > 100) {
                        // 100자 지점에서 가장 가까운 문장 끝 찾기
                        let cutPoint = 100;
                        for (let i = 100; i >= 70; i--) { // 70자부터 100자까지 역순으로 검색
                            if (text[i] === '.' || text[i] === '!' || text[i] === '?' || text[i] === '다' || text[i] === '요') {
                                // 한국어 문장 끝 패턴 확인
                                if (text[i] === '다' || text[i] === '요') {
                                    // '다'나 '요' 다음에 공백이나 문장부호가 있는지 확인
                                    if (i + 1 >= text.length || text[i + 1] === ' ' || text[i + 1] === '.' || text[i + 1] === '!' || text[i + 1] === '?') {
                                        cutPoint = i + 1;
                                        break;
                                    }
                                } else {
                                    cutPoint = i + 1;
                                    break;
                                }
                            }
                        }
                        text = text.substring(0, cutPoint).trim();
                    }
                    scoreDescription.textContent = text;
                } else {
                    scoreDescription.textContent = 'GPT가 분석한 결과입니다.';
                }
            }
            
            // 문장 구조 및 논리성 섹션 업데이트
            updateStructureAndLogicSection(result);
        }
        
        // 문장 구조 및 논리성 섹션 업데이트
        window.updateStructureAndLogicSection = function(result) {
            const structureText = document.querySelector('.structure-text');
            const structureNote = document.querySelector('.structure-note');
            
            if (structureText) {
                // GPT에서 제공된 structure_analysis 우선 사용
                if (result.structure_analysis && Array.isArray(result.structure_analysis)) {
                    structureText.textContent = result.structure_analysis.join(' ');
                    console.log('Updated structure text with GPT analysis:', result.structure_analysis);
                } else {
                    // GPT 데이터가 없는 경우 기본 분석 사용
                    const structureScore = result.structure_score || 0;
                    const logicScore = result.logic_score || 0;
                    const vocabularyScore = result.vocabulary_score || 0;
                    const creativityScore = result.creativity_score || 0;
                    
                    let structureItems = [];
                
                // 구조 점수에 따른 피드백
                if (structureScore >= 80) {
                    structureItems.push('복잡한 주제를 명확하고 논리적으로 전개하는 능력이 뛰어납니다.');
                } else if (structureScore >= 60) {
                    structureItems.push('주제를 체계적으로 구성하고 전개하는 능력이 양호합니다.');
                } else {
                    structureItems.push('문장 구조를 더욱 체계적으로 개선할 여지가 있습니다.');
                }
                
                // 어휘 점수에 따른 피드백
                if (vocabularyScore >= 80) {
                    structureItems.push('고급 어휘를 적절한 맥락에 배치하여 의미를 명확하게 전달합니다.');
                } else if (vocabularyScore >= 60) {
                    structureItems.push('적절한 어휘 선택으로 의미 전달이 명확합니다.');
                } else {
                    structureItems.push('어휘 선택의 다양성과 정확성을 높일 필요가 있습니다.');
                }
                
                // 논리 점수에 따른 피드백
                if (logicScore >= 80) {
                    structureItems.push('문장 간의 연결성이 자연스럽게 유지되어 전체적인 흐름이 매끄럽습니다.');
                } else if (logicScore >= 60) {
                    structureItems.push('논리적 전개가 대체로 잘 이루어지고 있습니다.');
                } else {
                    structureItems.push('논리적 연결성을 강화하여 글의 흐름을 개선할 수 있습니다.');
                }
                
                // 창의성 점수에 따른 피드백
                if (creativityScore >= 80) {
                    structureItems.push('추상적 개념을 구체적인 예시와 함께 설명하여 이해도를 높입니다.');
                } else if (creativityScore >= 60) {
                    structureItems.push('적절한 예시와 설명으로 내용을 효과적으로 전달합니다.');
                } else {
                    structureItems.push('구체적인 예시와 설명을 추가하여 내용을 더욱 풍부하게 만들 수 있습니다.');
                }
                
                // GPT의 강점과 개선점을 활용한 추가 피드백
                if (result.strengths && result.strengths.length > 0) {
                    const strength = result.strengths[0]; // 첫 번째 강점 사용
                    structureItems.push(`특히 "${strength}" 부분에서 뛰어난 능력을 보여줍니다.`);
                }
                
                if (result.improvements && result.improvements.length > 0) {
                    const improvement = result.improvements[0]; // 첫 번째 개선점 사용
                    structureItems.push(`"${improvement}" 영역에서 더욱 발전할 수 있습니다.`);
                }
                
                    // 텍스트 생성
                    structureText.textContent = structureItems.join(' ');
                }
            }
            
            // 구조 노트 업데이트
            if (structureNote) {
                const overallScore = result.overall_score || 0;
                let note = '';
                
                if (overallScore >= 90) {
                    note = '전문가 수준의 글쓰기 실력을 보여주시네요!';
                } else if (overallScore >= 80) {
                    note = '자신의 생각을 우수하게 표현하시네요!';
                } else if (overallScore >= 70) {
                    note = '잘 구성된 글을 작성하셨습니다!';
                } else if (overallScore >= 60) {
                    note = '기본적인 글쓰기 능력을 잘 보여주셨습니다!';
                } else {
                    note = '꾸준한 연습을 통해 더욱 발전할 수 있습니다!';
                }
                
                structureNote.textContent = note;
            }
        }
        
        // 상세 분석 결과 추가
        function addDetailedAnalysis(result) {
            const titleDesc = document.querySelector('.title-description');
            if (titleDesc) {
                const existingContent = titleDesc.innerHTML;
                titleDesc.innerHTML = existingContent + `
                    <div class="gpt-analysis" style="margin-top: 2rem; padding: 1.5rem; background: #1a1a1a; border: 1px solid #10A37F; border-radius: 12px;">
                        <h3 style="color: #10A37F; margin-bottom: 1rem;">🤖 GPT 분석 결과</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                            <div class="score-item">
                                <strong>어휘 표현력:</strong> ${result.vocabulary_score || 0}/100
                            </div>
                            <div class="score-item">
                                <strong>문장 구성:</strong> ${result.structure_score || 0}/100
                            </div>
                            <div class="score-item">
                                <strong>논리적 전개:</strong> ${result.logic_score || 0}/100
                            </div>
                            <div class="score-item">
                                <strong>창의성:</strong> ${result.creativity_score || 0}/100
                            </div>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <strong>강점:</strong><br>
                            ${(result.strengths || []).map(strength => `• ${strength}`).join('<br>')}
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <strong>개선점:</strong><br>
                            ${(result.improvements || []).map(improvement => `• ${improvement}`).join('<br>')}
                        </div>
                        <div>
                            <strong>상세 분석:</strong><br>
                            ${result.detailed_analysis || '상세 분석을 제공할 수 없습니다.'}
                        </div>
                    </div>
                `;
            }
            
        // 리라이팅 제안 섹션 업데이트
        updateRewritingSuggestion(result);
    }
    
    // 어휘 카드 업데이트 함수
    window.updateVocabularyCards = function(result) {
        console.log('Updating vocabulary cards with GPT result:', result);
        console.log('result.advanced_vocabulary:', result.advanced_vocabulary);
        console.log('vocabCards found:', document.querySelectorAll('.vocab-card').length);
        
        const vocabCards = document.querySelectorAll('.vocab-card');
        
        // 모든 카드를 먼저 숨김
        vocabCards.forEach(card => {
            card.style.display = 'none';
        });
        
        // advanced_vocabulary가 없으면 다른 필드에서 어휘 정보 추출 시도
        let vocabularyData = result.advanced_vocabulary;
        
        if (!vocabularyData && result.detailed_analysis) {
            // detailed_analysis에서 어휘 정보 추출 시도
            console.log('advanced_vocabulary가 없어서 detailed_analysis에서 어휘 추출 시도');
            vocabularyData = await extractVocabularyFromAnalysis(result.detailed_analysis);
        }
        
        if (!vocabularyData && result.strengths) {
            // strengths에서 어휘 정보 추출 시도
            console.log('detailed_analysis에서도 어휘를 찾지 못해 strengths에서 추출 시도');
            vocabularyData = await extractVocabularyFromStrengths(result.strengths);
        }
        
        if (vocabularyData && Array.isArray(vocabularyData)) {
            const vocabCount = vocabularyData.length;
            
            // 추출된 어휘로 카드 업데이트
            vocabularyData.forEach((vocab, index) => {
                if (vocabCards[index]) {
                    const card = vocabCards[index];
                    const wordElement = card.querySelector('.card-word');
                    const posElement = card.querySelector('.card-pos');
                    const descElement = card.querySelector('.card-desc');
                    
                    if (wordElement) wordElement.textContent = vocab.word;
                    if (posElement) posElement.textContent = vocab.pos;
                    if (descElement) descElement.textContent = vocab.definition;
                    
                    // 카드 표시
                    card.style.display = 'block';
                    
                    console.log(`Updated card ${index + 1}: ${vocab.word} (${vocab.pos})`);
                }
            });
            
            // 5개 이상인 경우 가로 스크롤 활성화
            if (vocabCount >= 5) {
                const cardsContainer = document.querySelector('.vocabulary-cards');
                if (cardsContainer) {
                    cardsContainer.style.overflowX = 'auto';
                    console.log(`Enabled horizontal scroll for ${vocabCount} cards`);
                }
            } else {
                // 5개 미만인 경우 가로 스크롤 비활성화
                const cardsContainer = document.querySelector('.vocabulary-cards');
                if (cardsContainer) {
                    cardsContainer.style.overflowX = 'hidden';
                    console.log(`Disabled horizontal scroll for ${vocabCount} cards`);
                }
            }
        } else {
            console.log('No advanced vocabulary data found, hiding all cards');
            console.log('GPT did not return advanced_vocabulary data. Cards will remain hidden.');
            
            // GPT 데이터가 없으면 모든 카드 숨김
            vocabCards.forEach(card => {
                card.style.display = 'none';
            });
        }
    }
    
    // 제공된 원본 텍스트에서 어휘 추출하는 함수
    async function extractVocabularyFromOriginalText(originalText) {
        console.log('extractVocabularyFromOriginalText called with:', originalText);
        
        if (!originalText) return null;
        
        // 한국어 어휘 추출 (조사, 어미 제거)
        const words = extractKoreanWords(originalText);
        console.log('추출된 단어들:', words);
        
        // 상위 수준의 어휘만 선택 (길이와 복잡성 기준)
        const advancedWords = selectAdvancedWords(words);
        console.log('선택된 고급 어휘들:', advancedWords);
        
        // 각 어휘의 품사와 정의 분석 (GPT에게 질문)
        return await analyzeWordsWithGPT(advancedWords);
    }
    
    // 한국어 단어 추출 (조사, 어미 제거)
    function extractKoreanWords(text) {
        // 조사 패턴
        const particles = ['은', '는', '이', '가', '을', '를', '에', '에서', '로', '으로', '와', '과', '의', '도', '만', '까지', '부터', '처럼', '같이', '보다', '에게', '한테', '께'];
        
        // 활용된 어미 패턴 (기본형이 아닌 활용형만)
        const conjugatedEndings = ['는', '은', '을', '를', '에', '에서', '로', '으로', '와', '과', '의', '도', '만', '까지', '부터', '처럼', '같이', '보다', '에게', '한테', '께', '고', '며', '면서', '하니', '해서', '하면', '하지만', '하므로', '하므로서', '하므로써'];
        
        // 2글자 이상의 한국어 단어 추출
        const words = text.match(/[가-힣]{2,}/g) || [];
        
        // 조사와 활용된 어미 제거하여 기본형 추출
        const cleanWords = words.map(word => {
            let cleanWord = word;
            
            // 조사 제거
            for (const particle of particles) {
                if (cleanWord.endsWith(particle)) {
                    cleanWord = cleanWord.slice(0, -particle.length);
                    break;
                }
            }
            
            // 활용된 어미 제거 (기본형이 아닌 활용형만)
            for (const ending of conjugatedEndings) {
                if (cleanWord.endsWith(ending)) {
                    cleanWord = cleanWord.slice(0, -ending.length);
                    break;
                }
            }
            
            // "~하다"로 끝나는 경우 기본형으로 복원
            if (cleanWord.endsWith('하') && !cleanWord.endsWith('하다')) {
                cleanWord = cleanWord + '다';
            }
            
            return cleanWord;
        }).filter(word => word.length >= 2); // 2글자 이상만 유지
        
        // 중복 제거
        return [...new Set(cleanWords)];
    }
    
    // 고급 어휘 선택 (길이와 복잡성 기준)
    function selectAdvancedWords(words) {
        // 길이순으로 정렬하고 상위 5개 선택
        return words
            .sort((a, b) => b.length - a.length)
            .slice(0, 5);
    }
    
    // GPT에게 단어 분석 요청
    async function analyzeWordsWithGPT(words) {
        console.log('GPT에게 단어 분석 요청:', words);
        
        try {
            // 단어들을 쉼표로 구분하여 문자열로 만들기
            const wordList = words.join(', ');
            
            // GPT에게 단어 분석 요청
            const response = await fetch('https://mundeuk-five.vercel.app/api/analyze', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text: `다음 한국어 단어들의 품사와 정의를 분석해주세요: ${wordList}`,
                    topic: "단어 분석"
                })
            });
            
            if (!response.ok) {
                throw new Error(`API 요청 실패: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('GPT 단어 분석 결과:', data);
            
            // GPT 응답에서 단어 정보 추출 (간단한 파싱)
            return parseWordAnalysisFromGPT(data, words);
            
        } catch (error) {
            console.error('GPT 단어 분석 오류:', error);
            // 오류 시 기본 분석 사용
            return words.map(word => analyzeWordBasic(word));
        }
    }
    
    // GPT 응답에서 단어 분석 정보 파싱
    function parseWordAnalysisFromGPT(gptResponse, words) {
        // GPT 응답에서 단어 정보를 추출하는 로직
        // 실제로는 GPT가 구조화된 응답을 반환하도록 프롬프트를 수정해야 함
        
        // 임시로 기본 분석 사용
        return words.map(word => analyzeWordBasic(word));
    }
    
    // 기본 단어 분석 (GPT 실패 시 사용)
    function analyzeWordBasic(word) {
        // 간단한 품사 분석
        let pos = "명사";
        let definition = "";
        
        // 동사 패턴
        if (word.endsWith('하다') || word.endsWith('되다')) {
            pos = "동사";
        }
        // 형용사 패턴
        else if (word.endsWith('적') || word.endsWith('스러운') || word.endsWith('한')) {
            pos = "형용사";
        }
        // 부사 패턴
        else if (word.endsWith('게') || word.endsWith('히') || word.endsWith('이')) {
            pos = "부사";
        }
        
        // 기본 정의 생성
        definition = generateDefinition(word, pos);
        
        return {
            word: word,
            pos: pos,
            definition: definition
        };
    }
    
    // 기본 정의 생성 (GPT 실패 시 사용)
    function generateDefinition(word, pos) {
        return `${word}의 의미`;
    }
    
    // detailed_analysis에서 어휘 추출하는 함수 (원본 텍스트 우선)
    async function extractVocabularyFromAnalysis(analysis) {
        console.log('extractVocabularyFromAnalysis called with:', analysis);
        
        // 원본 텍스트가 있으면 우선 사용
        const originalText = getOriginalText();
        if (originalText) {
            return await extractVocabularyFromOriginalText(originalText);
        }
        
        // 원본 텍스트가 없으면 분석 텍스트에서 추출
        return await extractVocabularyFromOriginalText(analysis);
    }
    
    // strengths에서 어휘 추출하는 함수
    async function extractVocabularyFromStrengths(strengths) {
        console.log('extractVocabularyFromStrengths called with:', strengths);
        if (!Array.isArray(strengths)) return null;
        
        const allText = strengths.join(' ');
        return await extractVocabularyFromOriginalText(allText);
    }
    
    // 원본 텍스트 가져오기
    function getOriginalText() {
        const urlParams = new URLSearchParams(window.location.search);
        let text = urlParams.get('text');
        
        if (!text) {
            text = localStorage.getItem('analysis_text');
        }
        
        return text;
    }
        
        // 리라이팅 제안 섹션 업데이트
        window.updateRewritingSuggestion = function(result) {
            const suggestionText = document.querySelector('.suggestion-text');
            const suggestionNote = document.querySelector('.suggestion-note');
            
            if (suggestionText && result.rewritten_text) {
                suggestionText.textContent = result.rewritten_text;
            }
            
            // 제안 노트는 항상 고정 (잘 쓴 글만 보여주기)
            if (suggestionNote) {
                suggestionNote.textContent = '아래는 상위 3% 회원님의 글입니다!';
            }
        }
        
    </script>
</body>
</html>
